\chapter{Introduction and Overview}

Most existing Unmanned Aerial Systems (UASs) require two or more human operators~\cite{GoodrichMorse2008,MurphyStoverPrattGriffin2006}. Standard UAS practice is to have one human to control the aerial vehicle and another to control the camera or other payloads. In addition to this a third human is often responsible for overseeing task completion and interfacing with the command structure. Although some argue persuasively that this is a desirable organization~\cite{MurphyBurke2010}, there is considerable interest in reducing the required number of humans and reducing human workload using improved autonomy and enhanced user interfaces~\cite{Cummings2007,MitchellCummings2005,goodrich2010fanout}.

UAV enabled wilderness search and rescue (WiSAR) has been a focus of the Human
Centered Machine Intelligence (HCMI), Multiple Agent Intelligent Coordination and Control (MAGICC) and Computer Vision (CV) labs at Brigham Young University since 2005.  In that time research has been conducted on human interaction with miniature unmanned aerial vehicles (mUAVs), improving target detection by enhancing video taken from a mUAV, integrating mUAVs into a search and rescue environment,
and improving the mUAVs chance of getting video footage of the target.   Given our prior experience with WiSAR~\cite{goodrich2009towards} we proposed to construct a UAS for that domain.  

The initial proposal was to move directly into software development.  See appendix~\ref{app:uas_wisar}.  During the requirement gathering and design steps of this project it became clear that in a system this complex a good design was paramount to success.  While prototypes of almost all the functionality existed, there was no way of knowing that the system as a whole would meet the requirements.  Instead of blindly pressing forward with the software development we decided that the more important scientific problem was to figure out how to model and validate the system design before implementation.

System modeling is not a new approach, though applying system modeling to human-machine systems requires extending most modeling languages.  There are many different modeling languages, each of which is designed to perform specific types of validation~\cite{bolton2013litreview}.  While it was possible to extend an existing modeling language to support our goals much like Bass et al. have done with EOFM~\cite{bass2011toward}, we chose to create our own framework for the following reasons:  
First, we wished to avoid semantically constrained languages which may not fully map to the model.  A common denominator among system modeling languages is the focus on well-defined tasks.  For new or emerging systems these detailed tasks are vague or undefined~\ref{humphrey2009information}.  We needed a highly flexible representation that allowed for varying levels of abstraction.  
Second, we desired to perform model checking directly on the modeling language itself instead of converting the language into another form for verification.
Finally, we desired to perform human workload measurements on the model as part of our approach to reducing the required number of humans involved in UASs.

The Model Abstraction Framework consists of the following core components:  Models, Modeling Interface, Simulator, and Workload Viewer.  A link to the source code is found in appendix~\ref{code}.  The Model Abstraction Framework uses Java as the primary modeling language.  The models consist of a set of Directed Role Graphs (DiRGs) representing the entities which are performing actions, and a Directed Team Graph (DiTG) representing the communication network between the different entities.  The model creates the DiRGs and DiTG by implementing the Modeling Interface, a set of Java interfaces and abstract classes.  The Modeling Interface allows the model to be expressed as a labeled state transition system to be run by the Simulator.  The Simulator is a core set of Java classes which simulates the running of the model and gathers workload metrics.  The simulation itself is performed inside of Java Pathfinder (JPF) which performs the model checking.  As JPF explores each path through the model, it collects the workload metrics for that path.  When the simulation is complete, the Workload Viewer allows us to analyze the human workload measurements, something which is relatively new to human machine interface validation~\cite{bolton2013litreview}.

We chose to base our workload measurements off of multiple resource theory~\cite{wickens2002multiple} with ties to queuing theory~\cite{newell1994unified} and operator fan-out theory~\cite{goodrich2010fanout}.  By relating these theories to the different operational components of the model we can obtain a quantitative measure of a humans workload for each time-step in the system.

As part of this work, we extended the Model Abstraction Framework by creating an XML Model Parser.  This component allowed models to be defined using XML and converted into Java.  The purpose of this exercise was two fold: constrain model implementations without losing flexibility and improve the time required for a human to build the model.  The results of the XML Model Parser were very positive, although the benefits for the time to build the model rapidly decreased as complexity increased.

We performed two case studies, one for WiSAR and another representing the introduction of a UAS into the National Air Space.  We chose WiSAR because of the host of modeling information available to us~\cite{adams2009cognitive}.  We chose to model a UAS operating within the National Air Space for two reasons: the current interest in the subject~\cite{nasroadmap} and the lack of modeling information, requiring the use of high levels of abstraction.  The results of the case studies show that the Model Abstraction Framework is capable of accurately modeling UASs.  They also demonstrate the ability to model systems using varying degrees of abstraction.  The verification of the metrics in this thesis is done by a {\em consistency} approach, showing that workload rises and falls as expected given known difficult and easy scenarios, respectively.  Future work will provide a more detailed verification.


\section{Overview and Papers}

Chapters 2 and 3 of this thesis consist of two published papers.  Chapter 2 introduces the DiRG and simulation framework.  Chapter 3 extends chapter 2 by adding the DiTG and workload metrics.

Chapter 2 presents our core conceptual model, details of the Model Abstraction Framework, and a WiSAR model implemented in Java.  It also presents how the Simulator is able to validate the model using JPF.

Chapter 3 presents an extension of our conceptual model in the form of the DiTG.  It also presents a formal taxonomy of workload metrics and how that taxonomy applies to our conceptual model.  Lastly it reports the results of adding the workload metrics into the simulation framework.  Much of the work performed for this paper was completed by others; it has been added to this thesis for completeness.

Chapter 4 presents an XML Model Extension for the Model Abstraction Framework which makes it easier for the modeler to create a labeled state transition system and reduces the likely hood of coding errors in the resulting Java implementation of that system.

Chapter 5 includes the changes made to the Modeling Interface, Simulator, and workload metrics as a result of observations and experiences from the previous chapters.  

Chapter 6 presents a case study which involves modeling the integration of a UAS into the NAS.  This case study uses the new XML modeling format to produce several versions of the Java model.  Lastly a detailed analysis and comparison of the results of these models is performed.

Chapter 7 contains our conclusions and the ideas we find most appealing for future work.

The appendices include the initial WiSAR proposal, the core modeling framework classes, an XML model, and simulation logs.