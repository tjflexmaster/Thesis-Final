\chapter{Introduction and Overview}
Most existing Unmanned Aerial Systems (UASs) require two or more human operators\cite{GoodrichMorse2008,MurphyStoverPrattGriffin2006}. Standard UAS practice is to have one human to control the aerial vehicle and another to control the camera or other payloads. In addition to this a third human is often responsible for overseeing task completion and interfacing with the command structure. Although some argue persuasively that this is a desirable organization~\cite{MurphyBurke2010}, there is considerable interest in reducing the required number of humans and reducing human workload using improved autonomy and enhanced user interfaces~\cite{Cummings2007,MitchellCummings2005,Goodrich2010}.

Our initial proposal was to move directly into software development.  Given our prior experience with UAS-enabled Wilderness Search and Rescue (WiSAR)~\cite{Goodrich2010} we proposed to construct a UAS for that domain.  During the requirement gathering and design steps of this project it became clear just how complex the system was.  While we had prototypes of almost all the functionality we had no way of measuring if the system itself would meet the requirements.  On top of that the limited time and resources meant that we would only get one shot at creating this system.  Because of this we decided to take a more conservative approach.  Instead of blindly pressing forward with the software development we decided that it would be more beneficial to validate our designs through modeling.

System modeling is not a new approach.  There are many different modeling languages each of which is designed to perform specific types of validation~\cite{bolton2013litreview}.  While it was possible to extend an existing modeling language to support our goals much like Bolton and Bass have done with EOFM~\cite{}.  We chose to create our own modeling language from scratch.  We chose this direction for a few reasons not the least of which being our lack of experience with other modeling languages.  Instead of learning a new language we desired to use a language and model checker we were already familiar with, Java and Java Pathfinder.  Also, a common denominator among system modeling languages is the focus on tasks.  This is ideal for modeling an existing system, however, for new systems these detailed tasks are vague or undefined~\cite{find evidence to back this up}.  We needed to be able to model and validate these tasks without needing to understand their details.  We also desired to measure human workload as a consequence of the system design, something which is relatively new to human machine interface validation~\cite{bolton2013litreview}.

Our modeling language allows models to be implemented in Java simply by implementing a core set of Java interfaces which comply with our conceptual model.  These models are then processed in a simulation framework which is run inside JPF for the model checking and metric gathering.  The conceptual model underneath the modeling framework consists of Directed Role Graphs (DiRGs) and Directed Team Graphs (DiTGs) which focus on the key Actors within the system and the communication channels which they use to perform their work.  The model itself is defined as a state machine.  This common approach to modeling allows us a flexible approach to abstraction while still allowing us to gather workload data and lends itself well to model checking.

We chose to base our workload measurements off of multiple resource theory~\cite{wickens} with ties to queing theory~\cite{queuetheory} and operator fan-out theory~\cite{}.  By relating these theories to the different operational components of the model we can obtain a quantitative measure of an Actors workload for each time-step in the system.

We performed two case studies, one for WiSAR and another representing the introduction of a UAS into the National Air Space (NAS).  We chose WiSAR because of the host of modeling information available to us~\cite{Adams2008}.  We chose to model a UAS operating within the NAS because of the current interest in the subject~\cite{UASinNAS} and the decided lack of modeling information available to us which required us to use high levels of abstraction.  The results of the case studies show that the modeling language we developed is capable of accurately modeling UASs.  They also demonstrate the ability to model systems using varying degrees of abstraction.  While the workload metrics are still unverified initial results appear very promising and trend well with known high workload areas.


\section{Overview and Papers}
Chapters 2 and 3 of this thesis consist of two published papers.  Chapter 2 introduces the DiRG and simulation framework.  Chapter 3 extends chapter 2 by adding the DiTG and workload metrics.

Chapter 2 presents our core conceptual model along with our implementation of this model in Java.  It also presents how our simulation framework is able to validate the model using JPF.

Chapter 3 presents an extension of our conceptual model in the form of the DiTG.  It also presents a formal taxonomy of workload metrics and how that taxonomy applies to our conceptual model.  Lastly it reports the results of adding the workload metrics into the simulation framework.

Chapter 4 includes the changes made to the conceptual model and simulation framework as a result of the work performed to obtain the results presented in chapter 3.  It also presents an XML modeling format which is meant to simplify the modeling process.

Chapter 5 presents a case study which involves modeling the introduction of a UAS into the NAS.  This case study uses the new XML modeling format to produce several versions of the Java model.  A detailed analysis and comparison of the results of these models is also given.

Chapter 6 contains the conclusions we have made about this research along with the avenues of future work which we find most interesting.

We also include the initial WiSAR proposal along with actual java code and raw metric gathering data to help the reader fully understand the work we have done.